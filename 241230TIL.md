## GPT APIì™€ RAG ê¸°ë°˜ ë¸”ë¡œê·¸ ì‘ì„± ë„êµ¬ ê°œë°œ

ë¸”ë¡œê·¸ ì‘ì„±ì„ ë•ëŠ” ì›¹ ì„œë¹„ìŠ¤ì˜ íŒŒì´ì¬ ì½”ë“œë¥¼ ê°œë°œí–ˆìŠµë‹ˆë‹¤. ì£¼ìš” ê¸°ëŠ¥ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

- RAG(Retrieval-Augmented Generation) ê¸°ë°˜ ì •ëŸ‰ ë°ì´í„° ê²€ìƒ‰
    - ë„¤ì´ë²„ ë‰´ìŠ¤ APIë¥¼ í™œìš©í•˜ì—¬ ê´€ë ¨ ê¸°ì‚¬ ê²€ìƒ‰
    - ê²€ìƒ‰ëœ ê¸°ì‚¬ì˜ ì œëª©ê³¼ URLì„ ìë™ìœ¼ë¡œ ì°¸ê³ ìë£Œë¡œ ì¶”ê°€
- ì‚¬ìš©ì ì¹œí™”ì  ê¸°ëŠ¥
    - ì„¹ì…˜ë³„ ë‹¤ì‹œì“°ê¸° ê¸°ëŠ¥
    - ì „ì²´ í…ìŠ¤íŠ¸ í´ë¦½ë³´ë“œ ë³µì‚¬
    - ì°¸ê³ ìë£Œ ê´€ë¦¬ ë° í‘œì‹œ

# ì°¸ê³ ìë£Œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
def fetch_quantitative_data(section_title, keyword):
    references = []
    try:
        query = f"{keyword} {section_title}"
        search_url = f"https://search.naver.com/search.naver?query={query}&where=news"
        response = requests.get(search_url, headers={'User-Agent': 'Mozilla/5.0'})
        soup = BeautifulSoup(response.text, 'html.parser')
        for item in soup.select('.news_area')[:2]:
            title_elem = item.select_one('.news_tit')
            if title_elem:
                references.append({
                    'title': title_elem.get('title', '').strip(),
                    'url': title_elem['href'],
                    'source': 'ë„¤ì´ë²„ ë‰´ìŠ¤'
                })
    except Exception as e:
        st.error(f"ë‰´ìŠ¤ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
    return references
    
# ì „ì²´ì½”ë“œ
import streamlit as st
import openai
import pyperclip  # í´ë¦½ë³´ë“œ ë³µì‚¬ ëª¨ë“ˆ
import requests
from bs4 import BeautifulSoup
import re
import os

# OpenAI API í‚¤ ì„¤ì •
openai.api_key = os.getenv('OPENAI_API_KEY')

# ì„¸ì…˜ ìƒíƒœ ì´ˆê¸°í™”
if 'introduction' not in st.session_state:
    st.session_state.introduction = None
if 'generated_content' not in st.session_state:
    st.session_state.generated_content = []
if 'references' not in st.session_state:
    st.session_state.references = []
if 'form_data' not in st.session_state:
    st.session_state.form_data = {
        'keyword': '',
        'target': '',
        'problem': '',
        'writer': '',
        'stories': []
    }
if 'content_generated' not in st.session_state:
    st.session_state.content_generated = False
if 'show_references' not in st.session_state:
    st.session_state.show_references = False

# í‚¤ì›Œë“œ í˜•íƒœì†Œ ë¶„ë¦¬ í•¨ìˆ˜
def split_keyword_into_morphemes(keyword):
    return re.split(r"[,\s\-]+", keyword)  # ê³µë°±, ì‰¼í‘œ, í•˜ì´í”ˆìœ¼ë¡œ ë¶„ë¦¬

# í‚¤ì›Œë“œ ì‚¬ìš© íšŸìˆ˜ ì œí•œ í•¨ìˆ˜
def limit_keyword_usage(text, keywords, max_count=20):
    for keyword in keywords:
        matches = list(re.finditer(fr"\b{re.escape(keyword)}\b", text, re.IGNORECASE))
        if len(matches) > max_count:
            for match in matches[max_count:]:
                text = text[:match.start()] + text[match.end():]
    return text

# ì„œë¡  ìƒì„± í•¨ìˆ˜
def generate_introduction(keyword, target, problem, writer):
    try:
        prompt = f"""
        ì£¼ì œ í‚¤ì›Œë“œ: {keyword}
        ëª©í‘œ ë…ì: {target}
        ë…ìì˜ ê³ ë¯¼: {problem}
        ì‘ì„±ì ê´€ì : {writer}

        ì„œë¡  ì‘ì„± ê·œì¹™:
        1. ë…ì ê³µê°, ì „ë¬¸ì„± ì œì‹œ, í•´ê²°ì±… ì•”ì‹œë¡œ êµ¬ì„±.
        2. ë¶„ëŸ‰: 370ì ë‚´ì™¸.
        """
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "ì „ë¬¸ì ì´ê³  ì‹ ë¢°ì„± ìˆëŠ” ë¸”ë¡œê·¸ë¥¼ ì‘ì„±í•˜ëŠ” ì‘ê°€ì…ë‹ˆë‹¤."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=1000
        )
        introduction = response.choices[0].message.content
        keywords = split_keyword_into_morphemes(keyword)
        return limit_keyword_usage(introduction, keywords)
    except Exception as e:
        st.error(f"ì„œë¡  ìƒì„± ì¤‘ ì˜¤ë¥˜: {str(e)}")
        return None

# ë³¸ë¬¸ ìƒì„± í•¨ìˆ˜
def generate_section_content(section_title, keyword, target_length):
    try:
        prompt = f"""
        ì£¼ì œ í‚¤ì›Œë“œ: {keyword}
        ì†Œì œëª©: {section_title}
        ë‚´ìš© ì‘ì„± ê·œì¹™:
        1. ë¶„ëŸ‰: {target_length}ì ë‚´ì™¸.
        """
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "ì „ë¬¸ì ì´ê³  ì‹ ë¢°ì„± ìˆëŠ” ê¸€ì„ ì‘ì„±í•˜ëŠ” ì‘ê°€ì…ë‹ˆë‹¤."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500,
            request_timeout=30
        )
        content = response.choices[0].message.content if response.choices else None
        if content:
            keywords = split_keyword_into_morphemes(keyword)
            return limit_keyword_usage(content, keywords)
        return content
    except Exception as e:
        st.error(f"'{section_title}' ì„¹ì…˜ ìƒì„± ì¤‘ ì˜¤ë¥˜: {str(e)}")
        return None

# ì°¸ê³ ìë£Œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
def fetch_quantitative_data(section_title, keyword):
    references = []
    try:
        query = f"{keyword} {section_title}"
        search_url = f"https://search.naver.com/search.naver?query={query}&where=news"
        response = requests.get(search_url, headers={'User-Agent': 'Mozilla/5.0'})
        soup = BeautifulSoup(response.text, 'html.parser')
        for item in soup.select('.news_area')[:2]:
            title_elem = item.select_one('.news_tit')
            if title_elem:
                references.append({
                    'title': title_elem.get('title', '').strip(),
                    'url': title_elem['href'],
                    'source': 'ë„¤ì´ë²„ ë‰´ìŠ¤'
                })
    except Exception as e:
        st.error(f"ë‰´ìŠ¤ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜: {str(e)}")
    return references

# ì°¸ê³ ìë£Œì™€ ì •ëŸ‰ ì§€í‘œ ë³¸ë¬¸ì— í†µí•©
def enhance_section_with_references(section_title, keyword, existing_text, references):
    if not references:
        st.warning("ê´€ë ¨ëœ ì •ëŸ‰ ë°ì´í„°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        return existing_text
    try:
        ref_summary = "\n".join([
            f"- [{ref['title']}]({ref['url']}) ({ref['source']})" for ref in references
        ])
        prompt = f"""
        ì£¼ì œ: {keyword}
        ì†Œì œëª©: {section_title}
        ê¸°ì¡´ ë‚´ìš©: {existing_text}

        ì°¸ê³ ìë£Œ:
        {ref_summary}

        ìœ„ ì°¸ê³ ìë£Œë¥¼ í™œìš©í•´ ê¸°ì¡´ í…ìŠ¤íŠ¸ë¥¼ ë³´ê°•í•´ì£¼ì„¸ìš”.
        """
        response = openai.ChatCompletion.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "ì „ë¬¸ì ì´ê³  ì‹ ë¢°ì„± ìˆëŠ” ê¸€ì„ ì‘ì„±í•˜ëŠ” ì‘ê°€ì…ë‹ˆë‹¤."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=1000
        )
        updated_text = response.choices[0].message.content
        keywords = split_keyword_into_morphemes(keyword)
        return limit_keyword_usage(updated_text, keywords)
    except Exception as e:
        st.error(f"ë³¸ë¬¸ ë³´ê°• ì¤‘ ì˜¤ë¥˜: {str(e)}")
        return existing_text

# í´ë¦½ë³´ë“œ ë³µì‚¬ í•¨ìˆ˜
def copy_to_clipboard():
    try:
        full_text = "\n\n".join(
            [st.session_state.introduction] + st.session_state.generated_content
        )
        pyperclip.copy(full_text)
        st.toast("âœ… í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!")
    except Exception as e:
        st.error(f"í´ë¦½ë³´ë“œ ë³µì‚¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")

# ë‹¤ì‹œì“°ê¸° í•¨ìˆ˜
def reset_session_state():
    st.session_state.introduction = None
    st.session_state.generated_content = []
    st.session_state.references = []
    st.session_state.form_data = {
        'keyword': '',
        'target': '',
        'problem': '',
        'writer': '',
        'stories': []
    }
    st.session_state.content_generated = False
    st.session_state.show_references = False

# ì°¸ê³ ìë£Œ ë³´ê¸° í•¨ìˆ˜
def display_references():
    st.subheader("ğŸ“š ì°¸ê³ ìë£Œ")
    if st.session_state.references:
        for ref in st.session_state.references:
            st.markdown(f"- [{ref['title']}]({ref['url']}) ({ref['source']})")
    else:
        st.info("ì°¸ê³ ìë£Œê°€ ì—†ìŠµë‹ˆë‹¤.")

# ë©”ì¸ í•¨ìˆ˜
def main():
    st.title("ë¸”ë¡œê·¸ì¹˜íŠ¸í‚¤ v2")

    # ì…ë ¥ í¼
    with st.form(key='input_form'):
        st.subheader("ğŸ“Œ í‚¤ì›Œë“œì™€ ë…ì ì„¤ì •")
        col1, col2 = st.columns(2)
        with col1:
            keyword = st.text_input("ì£¼ì œ í‚¤ì›Œë“œ", placeholder="ì˜ˆ: ë‹¤ì´ì–´íŠ¸, ì¬í…Œí¬ ë“±")
            target = st.text_input("ëª©í‘œ ë…ì", placeholder="ì˜ˆ: 30ëŒ€ ì§ì¥ì¸")
        with col2:
            problem = st.text_input("ë…ìì˜ ê³ ë¯¼/ë‹ˆì¦ˆ", placeholder="ì˜ˆ: ì‹œê°„ ë¶€ì¡±")
            writer = st.text_input("ì‘ì„±ì ê´€ì ", placeholder="ì˜ˆ: ì „ë¬¸ê°€, ê²½í—˜ ë§ì€ ì‚¬ëŒ")

        st.subheader("ğŸ“ ê¸€ êµ¬ì¡° ì„¤ê³„")
        stories = []
        for i in range(5):
            story = st.text_input(f"{i+1}ë²ˆì§¸ ì†Œì œëª©", key=f'story{i+1}')
            if story.strip():
                stories.append(story)

        submit = st.form_submit_button("âœ¨ ê¸€ ìƒì„±í•˜ê¸°")
        if submit and keyword and stories:
            st.session_state.form_data = {
                'keyword': keyword,
                'target': target,
                'problem': problem,
                'writer': writer,
                'stories': stories
            }
            st.session_state.content_generated = True

    # ì½˜í…ì¸  ìƒì„±
    if st.session_state.content_generated and not st.session_state.introduction:
        with st.spinner("ì½˜í…ì¸ ë¥¼ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤..."):
            form_data = st.session_state.form_data
            st.session_state.introduction = generate_introduction(
                keyword=form_data['keyword'],
                target=form_data['target'],
                problem=form_data['problem'],
                writer=form_data['writer']
            )
            total_length = 1850 // len(form_data['stories'])
            st.session_state.generated_content = [
                generate_section_content(title, form_data['keyword'], total_length)
                for title in form_data['stories']
            ]

    # ìƒì„±ëœ ì½˜í…ì¸  í‘œì‹œ (ì…ë ¥ í¼ ë°”ë¡œ ì•„ë˜)
    if st.session_state.content_generated:
        st.subheader("## ì„œë¡ ")
        st.markdown(st.session_state.introduction)

        st.subheader("## ë³¸ë¬¸")
        for i, content in enumerate(st.session_state.generated_content):
            st.markdown(f"### {st.session_state.form_data['stories'][i]}")
            st.markdown(content)

            # ì •ëŸ‰ ë°ì´í„° ì¶”ê°€ ë° ë‹¤ì‹œì“°ê¸°
            col1, col2 = st.columns([1, 1])
            with col1:
                if st.button(f"ì •ëŸ‰ ë°ì´í„° ì¶”ê°€ ({i+1})", key=f"add_ref_{i}"):
                    references = fetch_quantitative_data(
                        st.session_state.form_data['stories'][i],
                        st.session_state.form_data['keyword']
                    )
                    updated_text = enhance_section_with_references(
                        st.session_state.form_data['stories'][i],
                        st.session_state.form_data['keyword'],
                        content,
                        references
                    )
                    st.session_state.generated_content[i] = updated_text
                    st.session_state.references.extend(references)
            with col2:
                if st.button(f"ë‹¤ì‹œì“°ê¸° ({i+1})", key=f"rewrite_{i}"):
                    updated_text = generate_section_content(
                        st.session_state.form_data['stories'][i],
                        st.session_state.form_data['keyword'],
                        370
                    )
                    if updated_text:
                        st.session_state.generated_content[i] = updated_text

        # í•˜ë‹¨ ì‘ì—… ë²„íŠ¼ (í•œ ì—´ì— ë°°ì¹˜)
        st.markdown("---")
        col1, col2, col3 = st.columns([1, 1, 1])
        with col1:
            if st.button("ğŸ“‹ ë³µì‚¬í•˜ê¸°"):
                copy_to_clipboard()
        with col2:
            if st.button("ğŸ“š ì°¸ê³ ìë£Œ ë³´ê¸°"):
                st.session_state.show_references = True
        with col3:
            if st.button("ğŸ”„ ë‹¤ì‹œì“°ê¸° (ëª¨ë‘ ì´ˆê¸°í™”)"):
                reset_session_state()

    # ì°¸ê³ ìë£Œ í‘œì‹œ (ë§¨ í•˜ë‹¨)
    if st.session_state.show_references:
        display_references()

if __name__ == "__main__":
    main()