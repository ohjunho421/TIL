오늘진행한 코드카타

```python
# Python
최댓값과 최솟값
def solution(s):
    s=list(map(int,s.split()))
    result=f'{min(s)} {max(s)}'
    return result

정수 제곱근 판별
def solution(n):
    answer = 0
    if (n**(1/2)).is_integer():
        answer = (n**(1/2)+1)**2
    else: 
        answer = -1
    return answer
    
import math
def solution(n):
    answer = 0
    if math.sqrt(n).is_integer():
        answer = (n**(1/2)+1)**2
    else: 
        answer = -1
    return answer
    
두 개 뽑아서 더하기
def solution(numbers):
    answer = set()
    for i, n in enumerate(numbers):
        for j, num in enumerate(numbers):
            if i != j:
                answer.add(n + num)
    return sorted(answer)
```

Django Auth

## **01.** Auth

<aside>
✔️ Auth란 무엇일까요?

</aside>

### Auth란?

- 인증(Authentication)과 권한(Authorization)을 합쳐서 Auth라고 
대개 인증시스템이라고 명명합니다.
    - 인증(Authentication) : 내가 누구인지를 입증하는 것
    - 권한(Authorization) : 수행할 수 있는 자격 여부
- 
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/d6e2529e-5d14-46f3-a8d6-88332186133e/Untitled.png)
    
    - `django.contrib.auth` → 인증 핵심 로직과 관련 기본 모델
    - `django.contrib.contenttypes` → 사용자의 모델과 권한을 연결

---

## **02.** 쿠키(cookie)와 세션(session)

### HTTP

- HTTP 이야기가 계속 나오는 이유
    - 웹은 HTTP 방식을 사용해서 통신을 주고받고 있기때문입니다. 
    (웹에서의 데이터 교환의 기초)
- HTTP 특징
    - 비연결지향 (Connectionless)
        - 한 번 요청에 대한 응답을 하면 연결이 끊어짐
    - 무상태(Stateless)
        - 연결이 끊어지면 통신이 끝나고 서로를 잊어버림
        - 모든 메세지는 독립적
    - 만약 쿠키와 세션이 없다면?
        - 이전의 요청을 기억하지 못하게 됩니다.
        - 따라서 요청을 보낼 때 마다 매번 로그인을 해야합니다.
        - 이렇게 되면 너무 불편하겠죠?
    

### 쿠키(Cookie) 🍪

- 서버 → 웹 브라우저에 전달하는 작은 데이터 조각입니다.
    - 유저가 웹을 방문하게 되면 서버로부터 쿠키를 전달받습니다.
- Key-Value 형태로 데이터가 저장됩니다.
- 이후 동일한 서버에 보내는 모든 요청에 쿠키가 함께 전달됩니다.
- 쿠키 데이터는 유저의 로컬에 저장되는 정보입니다.

<aside>
☝ 쿠키는 유저의 작은 기억조각 !

- 장바구니 기능 (쿠키에 어떤 물건을 담았었는지 기억)
- 최근 검색한 상품들(쿠키에 기억) → 서버에서 받아서 맞춤형 광고
- 오늘 다시보지 않기 (쿠키에 기억)
</aside>

<aside>
💡 한 줄 정리
웹 페이지에 요청을 보내면 서버가 쿠키를 함께 전달하고
이후부터는 같은 서버에 보내는 모든 요청에 쿠키를 함께 담아서 요청을 보내게 된다.

</aside>

### 세션(Session)

<aside>
💡 세션은 서버와 클라이언트(브라우저)간 “상태(State)”를 기억하기 위한 것입니다!

</aside>

- **세션과 쿠키가 쓰이는 방법은 다음과 같습니다.**
    1. 클라이언트가 서버에 접속하면
    2. 서버가 특정 session id를 발급하고 기억
    3. session id 전달받아 쿠키에 저장
    4. 이후 클라이언트는 해당 쿠키를 이용해서 요청
    5. 서버에서는 쿠키에서 session id를 꺼내서 검증
    6. 검증에 성공했다면 알맞은 로직을 처리
    
    → 쿠키에 민감한 정보를 저장할 필요 없이 session id만 저장하고 서버에서 검증하는 방식으로 사용합니다.
    
    → 로그인은 이러한 절차로 구현됩니다.
    
- **쿠키의 수명**
    - 세션쿠키, Session Cookie
        - 현재의 세션이 종료되면(브라우저가 닫히면) 삭제됩니다.
    - 지속쿠키, Persistent Cookie
        - 디스크에 저장되며 브라우저를 닫거나 컴퓨터를 재시작해도 남아있습니다.
        - Max-Age를 지정하여 해당 기간이 지나면 삭제가 가능합니다.

### Django의 Session 과 Auth

![다 처리를 해주고 있다 !](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/ee025bdd-358b-4dff-9558-1f2c1d82185c/Untitled.png)

다 처리를 해주고 있다 !

- django에서 알아서 처리해주고 있기 때문에 직접 작성할 필요가 없습니다!

---

## **03.** Django의 Authentication System

### **로그인 구현하기**

<aside>
💡 로그인은 결국 Session을 Create하는 로직이라고 할 수 있습니다!

</aside>

**Authentication Form**

- Django의 Built-in Form
- 로그인을 위한 기본적인 form을 제공합니다.

**login()**

- 개발자가 직접 구현하지 않아도 login()함수 하나만 사용하면 됩니다!
- 사용자 로그인 처리를 해주고 내부적으로 session을 사용해서 user 정보 저장합니다.

1. `accounts` App을 새로 만들어 주세요.
    - 계정 관련된 로직은 `accounts` 앱으로 하는 것이 일반적입니다.
    - 이제 생성하고 등록하는 말은 굳이 또 하지 않을게요.
        
        **→앱 새로 만드는법**
        
         python [manage.py](http://manage.py) **startapp accounts**
        
2. project App의 urls와 `accounts` App의 urls를 연결해 주세요.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/5b2630a0-fda8-40f8-88bb-c0e3be59f416/Untitled.png)
    
3. 로그인 구현하기
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/c19867c6-40ec-4da8-8164-ba3a3aa6d6ec/Untitled.png)
    
    <aside>
    💡 음? 그런데 로그인해보려고 생각해보니…
    
    - 저는 회원가입을 한 기억이 없는데요?
    - 아니 그전에 ‘회원’에 대한 정의도 한적이 없는데요
    - Django는 기본적으로 모든게 갖춰져 있습니다.
        
        ![Django의 기본 유저 모델](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/8ba414ac-3e8f-4763-ada8-bc79f5b406ce/Untitled.png)
        
        Django의 기본 유저 모델
        
    </aside>
    
    **superuser란?** 
    
    - Django가 제공하는 Admin 기능에 접근할 수 있는 최고 권한 유저
    - User / Staff / Superuser 로 구분
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/38bcd274-f077-49bb-80cb-143eecd682cd/Untitled.png)
    
    **로그인 처리를 위한 view 작성하기**
    
    → session에 대한 작업은 모두 django 내부에서 처리합니다.
    
    **로그인 해보기**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/74c8b9d1-e4a1-4124-b308-826dce79888b/Untitled.png)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/3138d4e0-d69c-42ad-abb9-ac06d4659aef/Untitled.png)
    

**로그아웃 구현하기**

- 로그아웃이란?
    - 결국 서버의 세션 데이터를 지우는 것입니다!
- logout()
    - login()과 마찬가지로 logout()을 사용하면 간단하게 로그아웃을 사용할 수 있습니다.
    - 현재 request에서 가져온 session을 사용하여 DB에서 삭제합니다.
    - 클라이언트 쿠키에서도 삭제합니다.
- **생각해보자**

logout은 어떤 요청인가요? → DB를 조작하는 요청입니다.

그럼 어떤 방법으로 요청해야할까요? → POST!

**base.html**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/6804d36d-9e9f-4914-be18-f2de1e9b4b92/Untitled.png)

### HTTP 요청을 처리하는 다양한 방법

- Django가 HTTP요청을 처리하는 방법은 2가지가 있습니다.

<aside>
💡 Django shortcut functions

- `render()`- 템플릿을 랜더링해서 전달합니다.
- `redirect()` - 특정 경로로 요청을 전달합니다.
- `get_object_or_404()`
    - get을 호출한 후 객체가 없다면 404 에러를 raise하여 404 페이지로 이동시킵니다.
- `get_list_or_404()`
    - filter를 호출한 후 빈 리스트라면 404 에러를 raise하여 404페이지로 이동합니다.

- 존재하지 않는 게시글을 조회한다면 어떤 일이 일어날까요?
- `http://127.0.0.1:8000/articles/9999` 로 들어가면 아래의 화면이 나옵니다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/00377e81-43c6-409d-b6fa-9732876b52a3/Untitled.png)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/e093555f-2a22-457d-a4c8-d616a1e6ba2c/Untitled.png)
    

<aside>
💡 상태코드

400번대 코드, 즉 403, 404와 같은 코드라면 클라이언트의 요청에 문제가 있음을 나타내고

500번대 코드는 서버 내부에 문제가 생겨 요청을 처리할 수 없다는 것을 나타냅니다.d

존재하지 않는 게시물을 조회하려고 했기 때문에 클라이언트의 요청에 문제가 있음을 나타내는 400번대 상태코드(404 Not Fount)가 더 적절하겠죠?

</aside>

</aside>

<aside>
💡 View Decorators

- 여러가지 다양한 HTTP 기능을 제공하기 위한 데코레이터를 제공
- `require_http_methods()`
    - view 함수를 특정한 method 요청에 대해서만 허용
- `require_POST()`
    - POST 요청만 허용
- 적용해보기
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/f78cad10-a2c1-422a-bd89-da14d011abc8/Untitled.png)
    
</aside>

- **Template with Auth**
    - template으로는 우리가 context를 넘기지 않아도 자동으로 넘어가는 context들이 존재합니다.
    - `request.user` 도 그 중에 하나로 템플릿을 랜더링할때 현재 로그인한 사용자를 나타내는 `auth.User` 클래스의 인스턴스 또는 `AnonymousUser` 인스턴스를 `request.user`로 접근할 수 있습니다.
    - `base.html`에 소소하게 적용해보기
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/e59af324-1ea6-46c8-9339-2020e65f630f/Untitled.png)
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/b6e0a859-7144-4ec2-aefe-f3b8b381b877/Untitled.png)
        
    
- **접근 제한하기**
    - 로그인도 있겠다, 로그인이 된 유저와 아닌 유저가 이용할 수 있는 기능에 접근 제한을 둘 수 있으면 좋겠죠?
        - `is_authenticated` 속성 사용하기
        - `@login_required` 사용하기
    - **is_authenticated**
        1. `base.html`
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/df032bc0-d9fc-4093-a766-741d2fbfca1b/Untitled.png)
            
        2. `accounts/views.py`
        3. `articles/articles.html`
            
            ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/b6338cdc-90e6-4abd-ae62-9713d67215ab/Untitled.png)
            
    
    - **login_required**
        - 로그인이 되어있지 않은 상태에서 접근하면 `settings.LOGIN_URL` 에 설정된 경로로 이동시킵니다.
            - 기본 값은 `/accounts/login/`
        - 로그인이 되어있으면 view 로직을 실행합니다.
        - 로그인 성공시 이전 페이지로 자동으로 이동합니다.
            - 쿼리스크링에 `next` 로 저장해줍니다.
                - 별도 처리 안해주면 지정한 경로로 이동합니다.
                
        - 적용하기
            - `articles/views.py`
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/6ce3a8d4-ad6e-4e17-a284-1a2b641ea4a9/Untitled.png)
                
                - `/articles/create/` 로 강제 접근을 하면
                    
                    `/accounts/login/?next=/articles/create/` 로 리다이렉트됩니다.
                    
                
            - 한 번 테스트를 해보면 글 삭제시 아래와 같은 에러가 발생합니다.
                
                ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/e1b209c9-bc26-4295-a224-1dc0fa89fef7/ea9913e9-1398-458b-80af-3a26f6421b3a/Untitled.png)
                
                - 왜그럴까요?
                    1. 비로그인상태에서 삭제 클릭
                    2. 로그인 화면으로 리다이렉트
                    3. next=<삭제 url>
                    4. 로그인 성공
                    5. <삭제 url>로 리다이렉트 (GET)
                    6. 하지만 우리의 view는 GET을 허용하지 않음!
                    
                - 해결
                    - `login_required` 를 지우고 안쪽 로직에서 분리하도록 처리해서 해결할 수 있습니다.
                    
                    → 직접 접근하면 405 에러지만 이건 벗어난 flow에서 나오는 것입니다.
                    이전에 우리가 설계한 flow 자체가 에러였던 것입니다.